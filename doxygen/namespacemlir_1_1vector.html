<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::vector Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::vector Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1vector_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1vector_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1vector_1_1CombiningKindAttr.html">CombiningKindAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that specifies the combining function for <code>vector.contract</code>, and <code>vector.reduction</code>.  <a href="classmlir_1_1vector_1_1CombiningKindAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1DistributeOps.html">DistributeOps</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1UnrollVectorOptions.html">UnrollVectorOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that control the vector unrolling.  <a href="structmlir_1_1vector_1_1UnrollVectorOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorTransferFullPartialRewriter.html">VectorTransferFullPartialRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply <code>splitFullAndPartialTransfer</code> selectively via a pattern.  <a href="structmlir_1_1vector_1_1VectorTransferFullPartialRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to control the behavior of vector transform patterns.  <a href="structmlir_1_1vector_1_1VectorTransformsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acfee45e655b185bd625e2f7994dc2c50"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a> { <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38">BroadcastableToResult::Success</a> = 0, 
<a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a">BroadcastableToResult::SourceRankHigher</a> = 1, 
<a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463">BroadcastableToResult::DimensionMismatch</a> = 2, 
<a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248">BroadcastableToResult::SourceTypeNotAVector</a> = 3
 }<tr class="memdesc:acfee45e655b185bd625e2f7994dc2c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether <code>srcType</code> can be broadcast to <code>dstVectorType</code> under the semantics of the <code>vector.broadcast</code> op.  <a href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acfee45e655b185bd625e2f7994dc2c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8b08da9ea97e3670a2c8636b6773ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773ea">VectorContractLowering</a> { <a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773eaaaf6c6cf7a454b4ef4a850ac4d960a2cc">VectorContractLowering::Dot</a> = 0, 
<a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773eaa3543268dcb012cef3d015e2f64983872">VectorContractLowering::Matmul</a> = 1, 
<a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773eaa3080c8fd84516db2cf1d8dc557827994">VectorContractLowering::OuterProduct</a> = 2
 }<tr class="memdesc:aed8b08da9ea97e3670a2c8636b6773ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to control the lowering of <code>vector.contract</code> operations.  <a href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773ea">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aed8b08da9ea97e3670a2c8636b6773ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064c409437beb2a4fcd6d5425a6ac23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23">VectorTransposeLowering</a> { <a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23ac03c36af4417d41de5ccdc8abdad69ec">VectorTransposeLowering::EltWise</a> = 0, 
<a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23a745e3db6a7ffd50e1a72b39482f0882d">VectorTransposeLowering::Flat</a> = 1
 }<tr class="memdesc:a3064c409437beb2a4fcd6d5425a6ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to control the lowering of <code>vector.transpose</code> operations.  <a href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3064c409437beb2a4fcd6d5425a6ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6eb2276dcb5d10a00ae50149d53f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9">VectorTransferSplit</a> { <a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a6adf97f83acf6453d4a6a4b1070f3754">VectorTransferSplit::None</a> = 0, 
<a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a1ccd2cd55420e0abcdb19f15d086504f">VectorTransferSplit::VectorTransfer</a> = 1, 
<a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9aa2cb215f91a0fc3791c22a870940f877">VectorTransferSplit::LinalgCopy</a> = 2, 
<a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a152f64e8e144bfc4b3a3aa839a1101bc">VectorTransferSplit::ForceInBounds</a> = 3
 }<tr class="memdesc:a23a6eb2276dcb5d10a00ae50149d53f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to control the splitting of <code>vector.transfer</code> operations into in-bounds and out-of-bounds variants.  <a href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a23a6eb2276dcb5d10a00ae50149d53f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6888131b34a4dbf1064c8b912029e565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a6888131b34a4dbf1064c8b912029e565">isBroadcastableTo</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> srcType, VectorType dstVectorType, std::pair&lt; int, int &gt; *mismatchingDims=nullptr)</td></tr>
<tr class="separator:a6888131b34a4dbf1064c8b912029e565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5e3110101c89f482aaea6faebb2b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a9f5e3110101c89f482aaea6faebb2b12">populateVectorToVectorCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9f5e3110101c89f482aaea6faebb2b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of vector-to-vector canonicalization patterns.  <a href="#a9f5e3110101c89f482aaea6faebb2b12">More...</a><br /></td></tr>
<tr class="separator:a9f5e3110101c89f482aaea6faebb2b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34979ef68a6e3472b4f05adc99514850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a34979ef68a6e3472b4f05adc99514850">populateCastAwayVectorLeadingOneDimPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a34979ef68a6e3472b4f05adc99514850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of leading one dimension removal patterns.  <a href="#a34979ef68a6e3472b4f05adc99514850">More...</a><br /></td></tr>
<tr class="separator:a34979ef68a6e3472b4f05adc99514850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea5300a14d2a447eb0f946ad73ce3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a8ea5300a14d2a447eb0f946ad73ce3f0">populateBubbleVectorBitCastOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a8ea5300a14d2a447eb0f946ad73ce3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns that bubble up/down bitcast ops.  <a href="#a8ea5300a14d2a447eb0f946ad73ce3f0">More...</a><br /></td></tr>
<tr class="separator:a8ea5300a14d2a447eb0f946ad73ce3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d63e4f785ca9ab2fd1b8010bd6dfa82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5d63e4f785ca9ab2fd1b8010bd6dfa82">populateVectorTransferLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; maxTransferRank=<a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a6adf97f83acf6453d4a6a4b1070f3754">llvm::None</a>)</td></tr>
<tr class="memdesc:a5d63e4f785ca9ab2fd1b8010bd6dfa82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of transfer read/write lowering patterns.  <a href="#a5d63e4f785ca9ab2fd1b8010bd6dfa82">More...</a><br /></td></tr>
<tr class="separator:a5d63e4f785ca9ab2fd1b8010bd6dfa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bda0e3167482745b9570a160f81eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a02bda0e3167482745b9570a160f81eb7">populateVectorTransferPermutationMapLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a02bda0e3167482745b9570a160f81eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of transfer read/write lowering patterns that simplify the permutation map (e.g., converting it to a minor identity map) by inserting broadcasts and transposes.  <a href="#a02bda0e3167482745b9570a160f81eb7">More...</a><br /></td></tr>
<tr class="separator:a02bda0e3167482745b9570a160f81eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c433ef5cb91db482e34b63eb71bf310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a8c433ef5cb91db482e34b63eb71bf310">populateVectorMaskMaterializationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool enableIndexOptimizations)</td></tr>
<tr class="memdesc:a8c433ef5cb91db482e34b63eb71bf310"><td class="mdescLeft">&#160;</td><td class="mdescRight">These patterns materialize masks for various vector ops such as transfers.  <a href="#a8c433ef5cb91db482e34b63eb71bf310">More...</a><br /></td></tr>
<tr class="separator:a8c433ef5cb91db482e34b63eb71bf310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6924228bdd4694bef30911fc701c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a1a6924228bdd4694bef30911fc701c81">populateVectorMultiReductionLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool useInnerDimsForReduction=false)</td></tr>
<tr class="memdesc:a1a6924228bdd4694bef30911fc701c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector.multi_reduction op into a sequence of vector.reduction ops.  <a href="#a1a6924228bdd4694bef30911fc701c81">More...</a><br /></td></tr>
<tr class="separator:a1a6924228bdd4694bef30911fc701c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d6dcae55657b594b20a1785fb31058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a91d6dcae55657b594b20a1785fb31058">populatePropagateVectorDistributionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a91d6dcae55657b594b20a1785fb31058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to propagate insert_map/extract_map in the ssa chain.  <a href="#a91d6dcae55657b594b20a1785fb31058">More...</a><br /></td></tr>
<tr class="separator:a91d6dcae55657b594b20a1785fb31058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ab5cb922cfe44b9522407757c2acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#af46ab5cb922cfe44b9522407757c2acb">populateVectorBroadcastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:af46ab5cb922cfe44b9522407757c2acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns to progressively lower vector.broadcast ops on high-D vectors to low-D vector ops.  <a href="#af46ab5cb922cfe44b9522407757c2acb">More...</a><br /></td></tr>
<tr class="separator:af46ab5cb922cfe44b9522407757c2acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab512e449533533a49f19ad28791c4ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ab512e449533533a49f19ad28791c4ec2">populateVectorContractLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>())</td></tr>
<tr class="memdesc:ab512e449533533a49f19ad28791c4ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns to progressively lower vector contraction ops on high-D into low-D reduction and product ops.  <a href="#ab512e449533533a49f19ad28791c4ec2">More...</a><br /></td></tr>
<tr class="separator:ab512e449533533a49f19ad28791c4ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb266d3e2e70a159677656efc6ae4ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#afb266d3e2e70a159677656efc6ae4ab7">populateVectorMaskOpLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:afb266d3e2e70a159677656efc6ae4ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns to progressively lower vector mask ops into elementary selection and insertion ops.  <a href="#afb266d3e2e70a159677656efc6ae4ab7">More...</a><br /></td></tr>
<tr class="separator:afb266d3e2e70a159677656efc6ae4ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c244970a91f0b4817b0aa59a9ca21c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a0c244970a91f0b4817b0aa59a9ca21c7">populateVectorShapeCastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0c244970a91f0b4817b0aa59a9ca21c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns to progressively lower vector.shape_cast ops on high-D vectors into 1-D/2-D vector ops by generating data movement extract/insert ops.  <a href="#a0c244970a91f0b4817b0aa59a9ca21c7">More...</a><br /></td></tr>
<tr class="separator:a0c244970a91f0b4817b0aa59a9ca21c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3127cf112be7126905c917c934bb3f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a3127cf112be7126905c917c934bb3f3b">populateVectorTransposeLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>())</td></tr>
<tr class="memdesc:a3127cf112be7126905c917c934bb3f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert TransposeLowering patterns into extraction/insertion.  <a href="#a3127cf112be7126905c917c934bb3f3b">More...</a><br /></td></tr>
<tr class="separator:a3127cf112be7126905c917c934bb3f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ec3f2bf8bf50a023677a0981683da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a04ec3f2bf8bf50a023677a0981683da5">populateVetorReductionToContractPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a04ec3f2bf8bf50a023677a0981683da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect patterns to convert reduction op to vector.contract and fold transpose/broadcast ops into the contract.  <a href="#a04ec3f2bf8bf50a023677a0981683da5">More...</a><br /></td></tr>
<tr class="separator:a04ec3f2bf8bf50a023677a0981683da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ae3cb3b0a7edef27b564ca0603fedec4a">getVectorSubscriptType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder)</td></tr>
<tr class="memdesc:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer type required for subscripts in the vector dialect.  <a href="#ae3cb3b0a7edef27b564ca0603fedec4a">More...</a><br /></td></tr>
<tr class="separator:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0499bcd00b867b4665ddf0c939543cfb"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a0499bcd00b867b4665ddf0c939543cfb">getVectorSubscriptAttr</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="memdesc:a0499bcd00b867b4665ddf0c939543cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect.  <a href="#a0499bcd00b867b4665ddf0c939543cfb">More...</a><br /></td></tr>
<tr class="separator:a0499bcd00b867b4665ddf0c939543cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eab6605a007c4bcdf0eb06704946e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a4eab6605a007c4bcdf0eb06704946e18">getVectorReductionOp</a> (AtomicRMWKind op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> vector)</td></tr>
<tr class="memdesc:a4eab6605a007c4bcdf0eb06704946e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value obtained by reducing the vector into a scalar using the operation kind associated with a binary AtomicRMWKind op.  <a href="#a4eab6605a007c4bcdf0eb06704946e18">More...</a><br /></td></tr>
<tr class="separator:a4eab6605a007c4bcdf0eb06704946e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5448f398cc56b9e9ba3c85b71ef9f6c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5448f398cc56b9e9ba3c85b71ef9f6c6">isLastMemrefDimUnitStride</a> (MemRefType type)</td></tr>
<tr class="memdesc:a5448f398cc56b9e9ba3c85b71ef9f6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the last dimension of the <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> has unit stride.  <a href="#a5448f398cc56b9e9ba3c85b71ef9f6c6">More...</a><br /></td></tr>
<tr class="separator:a5448f398cc56b9e9ba3c85b71ef9f6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4c1ce9773d3ef4d2040f4574fcaf81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2d4c1ce9773d3ef4d2040f4574fcaf81">populateVectorInsertExtractStridedSliceTransforms</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2d4c1ce9773d3ef4d2040f4574fcaf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>patterns</code> with the following patterns.  <a href="#a2d4c1ce9773d3ef4d2040f4574fcaf81">More...</a><br /></td></tr>
<tr class="separator:a2d4c1ce9773d3ef4d2040f4574fcaf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67598e1a27e2a602e406cb4935ca2d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a67598e1a27e2a602e406cb4935ca2d36">populateVectorUnrollPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1vector_1_1UnrollVectorOptions.html">UnrollVectorOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a67598e1a27e2a602e406cb4935ca2d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of pattern to unroll vector operations to a smaller shapes.  <a href="#a67598e1a27e2a602e406cb4935ca2d36">More...</a><br /></td></tr>
<tr class="separator:a67598e1a27e2a602e406cb4935ca2d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad058822dcf769d94cfaba06f1473d6c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad058822dcf769d94cfaba06f1473d6c4">populateVectorTransferCollapseInnerMostContiguousDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad058822dcf769d94cfaba06f1473d6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to reduce the rank of the operands of vector transfer ops to operate on the largest contigious vector.  <a href="#ad058822dcf769d94cfaba06f1473d6c4">More...</a><br /></td></tr>
<tr class="separator:ad058822dcf769d94cfaba06f1473d6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1dd46b0167a6584fc56b4ac45a1c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2b1dd46b0167a6584fc56b4ac45a1c1a">splitFullAndPartialTransferPrecondition</a> (VectorTransferOpInterface xferOp)</td></tr>
<tr class="memdesc:a2b1dd46b0167a6584fc56b4ac45a1c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath.  <a href="#a2b1dd46b0167a6584fc56b4ac45a1c1a">More...</a><br /></td></tr>
<tr class="separator:a2b1dd46b0167a6584fc56b4ac45a1c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea008e69d7dd969b5e885803b759a338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aea008e69d7dd969b5e885803b759a338">splitFullAndPartialTransfer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, VectorTransferOpInterface xferOp, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>(), scf::IfOp *ifOp=nullptr)</td></tr>
<tr class="memdesc:aea008e69d7dd969b5e885803b759a338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath.  <a href="#aea008e69d7dd969b5e885803b759a338">More...</a><br /></td></tr>
<tr class="separator:aea008e69d7dd969b5e885803b759a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18449baca22ab874d5f2d596fd5d410f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1vector_1_1DistributeOps.html">DistributeOps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a18449baca22ab874d5f2d596fd5d410f">distributPointwiseVectorOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; id, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; multiplicity, const <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;<a class="el" href="ComprehensiveBufferize_8cpp.html#a2ca7063639bfcde8e71436b396374864">map</a>)</td></tr>
<tr class="memdesc:a18449baca22ab874d5f2d596fd5d410f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute a N-D vector pointwise operation over a range of given ids taking <em>all</em> values in [0 .  <a href="#a18449baca22ab874d5f2d596fd5d410f">More...</a><br /></td></tr>
<tr class="separator:a18449baca22ab874d5f2d596fd5d410f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d04193b4ea065cbb468158c3a7e4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ab5d04193b4ea065cbb468158c3a7e4a2">transferOpflowOpt</a> (FuncOp func)</td></tr>
<tr class="memdesc:ab5d04193b4ea065cbb468158c3a7e4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements transfer op write to read forwarding and dead transfer write optimizations.  <a href="#ab5d04193b4ea065cbb468158c3a7e4a2">More...</a><br /></td></tr>
<tr class="separator:ab5d04193b4ea065cbb468158c3a7e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bd96ceaaff937da9c8067138e02591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ab0bd96ceaaff937da9c8067138e02591">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, int64_t dim)</td></tr>
<tr class="memdesc:ab0bd96ceaaff937da9c8067138e02591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>.  <a href="#ab0bd96ceaaff937da9c8067138e02591">More...</a><br /></td></tr>
<tr class="separator:ab0bd96ceaaff937da9c8067138e02591"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acfee45e655b185bd625e2f7994dc2c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee45e655b185bd625e2f7994dc2c50">&#9670;&nbsp;</a></span>BroadcastableToResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">mlir::vector::BroadcastableToResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether <code>srcType</code> can be broadcast to <code>dstVectorType</code> under the semantics of the <code>vector.broadcast</code> op. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a"></a>SourceRankHigher&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463"></a>DimensionMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248"></a>SourceTypeNotAVector&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00045">45</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a id="aed8b08da9ea97e3670a2c8636b6773ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8b08da9ea97e3670a2c8636b6773ea">&#9670;&nbsp;</a></span>VectorContractLowering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773ea">mlir::vector::VectorContractLowering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to control the lowering of <code>vector.contract</code> operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed8b08da9ea97e3670a2c8636b6773eaaaf6c6cf7a454b4ef4a850ac4d960a2cc"></a>Dot&#160;</td><td class="fielddoc"><p>Progressively lower to finer grained <code>vector.contract</code> and dot-products. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed8b08da9ea97e3670a2c8636b6773eaa3543268dcb012cef3d015e2f64983872"></a>Matmul&#160;</td><td class="fielddoc"><p>Lower to <code>vector.matrix_multiply</code>, maps 1-1 to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> matrix intrinsics. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed8b08da9ea97e3670a2c8636b6773eaa3080c8fd84516db2cf1d8dc557827994"></a>OuterProduct&#160;</td><td class="fielddoc"><p>Lower to <code>vector.outerproduct</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00140">140</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a id="a23a6eb2276dcb5d10a00ae50149d53f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a6eb2276dcb5d10a00ae50149d53f9">&#9670;&nbsp;</a></span>VectorTransferSplit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9">mlir::vector::VectorTransferSplit</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to control the splitting of <code>vector.transfer</code> operations into in-bounds and out-of-bounds variants. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Do not split vector transfer operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9a1ccd2cd55420e0abcdb19f15d086504f"></a>VectorTransfer&#160;</td><td class="fielddoc"><p>Split using in-bounds + out-of-bounds vector.transfer operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9aa2cb215f91a0fc3791c22a870940f877"></a>LinalgCopy&#160;</td><td class="fielddoc"><p>Split using an in-bounds vector.transfer + linalg.fill + linalg.copy operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9a152f64e8e144bfc4b3a3aa839a1101bc"></a>ForceInBounds&#160;</td><td class="fielddoc"><p>Do not split vector transfer operation but instead mark it as "in-bounds". </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00158">158</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a id="a3064c409437beb2a4fcd6d5425a6ac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064c409437beb2a4fcd6d5425a6ac23">&#9670;&nbsp;</a></span>VectorTransposeLowering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23">mlir::vector::VectorTransposeLowering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to control the lowering of <code>vector.transpose</code> operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3064c409437beb2a4fcd6d5425a6ac23ac03c36af4417d41de5ccdc8abdad69ec"></a>EltWise&#160;</td><td class="fielddoc"><p>Lower transpose into element-wise extract and inserts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3064c409437beb2a4fcd6d5425a6ac23a745e3db6a7ffd50e1a72b39482f0882d"></a>Flat&#160;</td><td class="fielddoc"><p>Lower 2-D transpose to <code>vector.flat_transpose</code>, maps 1-1 to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> matrix intrinsics. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00149">149</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab0bd96ceaaff937da9c8067138e02591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bd96ceaaff937da9c8067138e02591">&#9670;&nbsp;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00035">35</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00421">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, and <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">mlir::linalg::applyPermutationToVector()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01950">createInBoundsCond()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01419">createNewAllocDeallocPairForShapedValue()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02041">createSubViewIntersection()</a>, <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00432">genBuffers()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00167">mlir::linalg::getDynOperands()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00588">mlir::linalg::makeTiledShape()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03656">MaterializeTransferMask&lt; ConcreteOp &gt;::matchAndRewrite()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00526">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="a18449baca22ab874d5f2d596fd5d410f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18449baca22ab874d5f2d596fd5d410f">&#9670;&nbsp;</a></span>distributPointwiseVectorOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1vector_1_1DistributeOps.html">mlir::vector::DistributeOps</a> &gt; mlir::vector::distributPointwiseVectorOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>multiplicity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distribute a N-D vector pointwise operation over a range of given ids taking <em>all</em> values in [0 . </p>
<p>. multiplicity - 1] (e.g. loop induction variable or SPMD id). This transformation only inserts vector.extract_map/vector.insert_map. It is meant to be used with canonicalizations pattern to propagate and fold the vector insert_map/extract_map operations. Transforms: to: v = arith.addf a, b : vector&lt;32xf32&gt; ev = vector.extract_map v, id, 32 : vector&lt;32xf32&gt; into vector&lt;1xf32&gt; nv = vector.insert_map ev, id, 32 : vector&lt;1xf32&gt; into vector&lt;32xf32&gt; </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02473">2473</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00407">mlir::OpBuilder::create()</a>, <a class="el" href="Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00165">mlir::vector::DistributeOps::extract</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00317">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00283">mlir::Operation::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00286">mlir::Operation::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00326">mlir::AffineMap::getResults()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00166">mlir::vector::DistributeOps::insert</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00193">map()</a>, and <a class="el" href="Builders_8h_source.html#l00328">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="a4eab6605a007c4bcdf0eb06704946e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eab6605a007c4bcdf0eb06704946e18">&#9670;&nbsp;</a></span>getVectorReductionOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::getVectorReductionOp </td>
          <td>(</td>
          <td class="paramtype">AtomicRMWKind&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value obtained by reducing the vector into a scalar using the operation kind associated with a binary AtomicRMWKind op. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00359">359</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8h_source.html#l00407">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00477">mlir::emitOptionalError()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00639">getElementType()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="Builders_8cpp_source.html#l00205">mlir::Builder::getStringAttr()</a>, and <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="a0499bcd00b867b4665ddf0c939543cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0499bcd00b867b4665ddf0c939543cfb">&#9670;&nbsp;</a></span>getVectorSubscriptAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayAttr mlir::vector::getVectorSubscriptAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00249">249</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00224">mlir::Builder::getI64ArrayAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l02050">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00847">inferExtractOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01975">inferStridedSliceOpResultType()</a>, <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l01536">verify()</a>.</p>

</div>
</div>
<a id="ae3cb3b0a7edef27b564ca0603fedec4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cb3b0a7edef27b564ca0603fedec4a">&#9670;&nbsp;</a></span>getVectorSubscriptType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerType mlir::vector::getVectorSubscriptType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00245">245</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00062">mlir::Builder::getIntegerType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="a6888131b34a4dbf1064c8b912029e565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6888131b34a4dbf1064c8b912029e565">&#9670;&nbsp;</a></span>isBroadcastableTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a> mlir::vector::isBroadcastableTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>srcType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>dstVectorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt; *&#160;</td>
          <td class="paramname"><em>mismatchingDims</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l01328">1328</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463">DimensionMismatch</a>, <a class="el" href="Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00024">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Types_8cpp_source.html#l00089">mlir::Type::isIntOrIndexOrFloat()</a>, <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a">SourceRankHigher</a>, <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248">SourceTypeNotAVector</a>, and <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38">Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00166">broadcastIfNeeded()</a>.</p>

</div>
</div>
<a id="a5448f398cc56b9e9ba3c85b71ef9f6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5448f398cc56b9e9ba3c85b71ef9f6c6">&#9670;&nbsp;</a></span>isLastMemrefDimUnitStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::isLastMemrefDimUnitStride </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the last dimension of the <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> has unit stride. </p>
<p>Also return true for memrefs with no strides. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00114">114</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00928">mlir::getStridesAndOffset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l02640">foldTransferInBoundsAttribute()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02703">TransferReadToVectorLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02824">TransferWriteToVectorStoreLowering::matchAndRewrite()</a>, and <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="a8ea5300a14d2a447eb0f946ad73ce3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea5300a14d2a447eb0f946ad73ce3f0">&#9670;&nbsp;</a></span>populateBubbleVectorBitCastOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateBubbleVectorBitCastOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns that bubble up/down bitcast ops. </p>
<p>These patterns move vector.bitcast ops to be before insert ops or after extract ops where suitable. With them, bitcast will happen on smaller vectors and there are more chances to share extract/insert ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03828">3828</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a34979ef68a6e3472b4f05adc99514850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34979ef68a6e3472b4f05adc99514850">&#9670;&nbsp;</a></span>populateCastAwayVectorLeadingOneDimPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateCastAwayVectorLeadingOneDimPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of leading one dimension removal patterns. </p>
<p>These patterns insert vector.shape_cast to remove leading one dimensions to expose more canonical forms of read/write/insert/extract operations. With them, there are more chances that we can cancel out extract-insert pairs or forward write-read pairs. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03816">3816</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a91d6dcae55657b594b20a1785fb31058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d6dcae55657b594b20a1785fb31058">&#9670;&nbsp;</a></span>populatePropagateVectorDistributionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populatePropagateVectorDistributionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to propagate insert_map/extract_map in the ssa chain. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03809">3809</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af46ab5cb922cfe44b9522407757c2acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ab5cb922cfe44b9522407757c2acb">&#9670;&nbsp;</a></span>populateVectorBroadcastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorBroadcastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns to progressively lower vector.broadcast ops on high-D vectors to low-D vector ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03835">3835</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="ab512e449533533a49f19ad28791c4ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab512e449533533a49f19ad28791c4ec2">&#9670;&nbsp;</a></span>populateVectorContractLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorContractLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns to progressively lower vector contraction ops on high-D into low-D reduction and product ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03853">3853</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="a2d4c1ce9773d3ef4d2040f4574fcaf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4c1ce9773d3ef4d2040f4574fcaf81">&#9670;&nbsp;</a></span>populateVectorInsertExtractStridedSliceTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorInsertExtractStridedSliceTransforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>patterns</code> with the following patterns. </p>
<p>Populate the given list with patterns that convert from <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.</p>
<h1>[<a class="el" href="classVectorInsertStridedSliceOpDifferentRankRewritePattern.html" title="RewritePattern for InsertStridedSliceOp where source and destination vectors have different ranks...">VectorInsertStridedSliceOpDifferentRankRewritePattern</a>] </h1>
<p><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> for InsertStridedSliceOp where source and destination vectors have different ranks.</p>
<p>When ranks are different, InsertStridedSlice needs to extract a properly ranked vector from the destination vector into which to insert. This pattern only takes care of this extraction part and forwards the rest to [<a class="el" href="classVectorInsertStridedSliceOpSameRankRewritePattern.html" title="RewritePattern for InsertStridedSliceOp where source and destination vectors have the same rank...">VectorInsertStridedSliceOpSameRankRewritePattern</a>].</p>
<p>For a k-D source and n-D destination vector (k &lt; n), we emit:</p><ol type="1">
<li>ExtractOp to extract the (unique) (n-1)-D subvector into which to insert the k-D source.</li>
<li>k-D -&gt; (n-1)-D InsertStridedSlice op</li>
<li>InsertOp that is the reverse of 1.</li>
</ol>
<h1>[<a class="el" href="classVectorInsertStridedSliceOpSameRankRewritePattern.html" title="RewritePattern for InsertStridedSliceOp where source and destination vectors have the same rank...">VectorInsertStridedSliceOpSameRankRewritePattern</a>] </h1>
<p><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> for InsertStridedSliceOp where source and destination vectors have the same rank. For each outermost index in the slice: begin end stride [offset : offset+size*stride : stride]</p><ol type="1">
<li>ExtractOp one (k-1)-D source subvector and one (n-1)-D dest subvector.</li>
<li>InsertStridedSlice (k-1)-D into (n-1)-D</li>
<li>the destination subvector is inserted back in the proper place</li>
</ol>
<ol type="1">
<li>InsertOp that is the reverse of 1.</li>
</ol>
<h1>[<a class="el" href="classVectorExtractStridedSliceOpRewritePattern.html" title="Progressive lowering of ExtractStridedSliceOp to either: ">VectorExtractStridedSliceOpRewritePattern</a>] </h1>
<p>Progressive lowering of ExtractStridedSliceOp to either:</p><ol type="1">
<li>single offset extract as a direct vector::ShuffleOp.</li>
<li>ExtractOp/ExtractElementOp + lower rank ExtractStridedSliceOp + InsertOp/InsertElementOp for the n-D case. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00230">230</a> of file <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html">VectorInsertExtractStridedSliceRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01033">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a8c433ef5cb91db482e34b63eb71bf310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c433ef5cb91db482e34b63eb71bf310">&#9670;&nbsp;</a></span>populateVectorMaskMaterializationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorMaskMaterializationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableIndexOptimizations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These patterns materialize masks for various vector ops such as transfers. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03801">3801</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="afb266d3e2e70a159677656efc6ae4ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb266d3e2e70a159677656efc6ae4ab7">&#9670;&nbsp;</a></span>populateVectorMaskOpLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorMaskOpLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns to progressively lower vector mask ops into elementary selection and insertion ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03840">3840</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="a1a6924228bdd4694bef30911fc701c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6924228bdd4694bef30911fc701c81">&#9670;&nbsp;</a></span>populateVectorMultiReductionLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorMultiReductionLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useInnerDimsForReduction</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector.multi_reduction op into a sequence of vector.reduction ops. </p>
<p>The patterns comprise:</p><ul>
<li><a class="el" href="classInnerOuterDimReductionConversion.html" title="This file implements the following transformations as composable atomic patterns. ...">InnerOuterDimReductionConversion</a>: rewrites vector.multi_reduction such that all reduction dimensions are either innermost or outermost, by adding the proper vector.transpose operations.</li>
<li><a class="el" href="classReduceMultiDimReductionRank.html" title="Reduces the rank of vector.multi_reduction nd -&gt; 2d given all reduction dimensions are either inner m...">ReduceMultiDimReductionRank</a>: once in innermost or outermost reduction form, rewrites n-D vector.multi_reduction into 2-D vector.multi_reduction, by introducing vector.shape_cast ops to collapse + multi-reduce + expand back.</li>
<li><a class="el" href="structTwoDimMultiReductionToElementWise.html" title="Unrolls vector.multi_reduction with outermost reductions and combines results. ">TwoDimMultiReductionToElementWise</a>: once in 2-D vector.multi_reduction form, with an <b>outermost</b> reduction dimension, unroll the outer dimension to obtain a sequence of 1-D vector ops. This also has an opportunity for tree-reduction (in the future).</li>
<li><a class="el" href="structTwoDimMultiReductionToReduction.html" title="Converts 2d vector.multi_reduction with inner most reduction dimension into a sequence of vector...">TwoDimMultiReductionToReduction</a>: once in 2-D vector.multi_reduction form, with an <b>innermost</b> reduction dimension, unroll the outer dimension to obtain a sequence of extract + vector.reduction + insert. This can further lower to horizontal reduction ops.</li>
<li><a class="el" href="structOneDimMultiReductionToTwoDim.html" title="Converts 1d vector.multi_reduction with a single reduction dimension to a 2d form with both a single ...">OneDimMultiReductionToTwoDim</a>: for cases that reduce to 1-D vector&lt;k&gt; reduction (and are thus missing either a parallel or a reduction), we lift them back up to 2-D with a simple vector.shape_cast to vector&lt;1xk&gt; so that the other patterns can kick in, thus fully exiting out of the vector.multi_reduction abstraction. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00400">400</a> of file <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html">VectorMultiDimReductionTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a0c244970a91f0b4817b0aa59a9ca21c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c244970a91f0b4817b0aa59a9ca21c7">&#9670;&nbsp;</a></span>populateVectorShapeCastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorShapeCastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns to progressively lower vector.shape_cast ops on high-D vectors into 1-D/2-D vector ops by generating data movement extract/insert ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03846">3846</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="a9f5e3110101c89f482aaea6faebb2b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5e3110101c89f482aaea6faebb2b12">&#9670;&nbsp;</a></span>populateVectorToVectorCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorToVectorCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of vector-to-vector canonicalization patterns. </p>

</div>
</div>
<a id="ad058822dcf769d94cfaba06f1473d6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad058822dcf769d94cfaba06f1473d6c4">&#9670;&nbsp;</a></span>populateVectorTransferCollapseInnerMostContiguousDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransferCollapseInnerMostContiguousDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to reduce the rank of the operands of vector transfer ops to operate on the largest contigious vector. </p>
<p>These patterns are useful when lowering to dialects with 1d vector type such as llvm and it will result fewer memory reads. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03897">3897</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l03889">populateVectorUnrollPatterns()</a>, and <a class="el" href="VectorTransforms_8h_source.html#l00051">mlir::vector::UnrollVectorOptions::setNativeShape()</a>.</p>

</div>
</div>
<a id="a5d63e4f785ca9ab2fd1b8010bd6dfa82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d63e4f785ca9ab2fd1b8010bd6dfa82">&#9670;&nbsp;</a></span>populateVectorTransferLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransferLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>maxTransferRank</em> = <code><a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a6adf97f83acf6453d4a6a4b1070f3754">llvm::None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of transfer read/write lowering patterns. </p>
<p>These patterns lower transfer ops to simpler ops like <code>vector.load</code>, <code>vector.store</code> and <code>vector.broadcast</code>. Only transfers with a transfer rank of a most <code>maxTransferRank</code> are lowered. This is useful when combined with VectorToSCF, which reduces the rank of vector transfer ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03879">3879</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01033">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a02bda0e3167482745b9570a160f81eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bda0e3167482745b9570a160f81eb7">&#9670;&nbsp;</a></span>populateVectorTransferPermutationMapLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransferPermutationMapLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of transfer read/write lowering patterns that simplify the permutation map (e.g., converting it to a minor identity map) by inserting broadcasts and transposes. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03872">3872</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToSCF_8cpp_source.html#l01251">mlir::populateVectorToSCFConversionPatterns()</a>.</p>

</div>
</div>
<a id="a3127cf112be7126905c917c934bb3f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3127cf112be7126905c917c934bb3f3b">&#9670;&nbsp;</a></span>populateVectorTransposeLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransposeLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert TransposeLowering patterns into extraction/insertion. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03861">3861</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="a67598e1a27e2a602e406cb4935ca2d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67598e1a27e2a602e406cb4935ca2d36">&#9670;&nbsp;</a></span>populateVectorUnrollPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorUnrollPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1vector_1_1UnrollVectorOptions.html">UnrollVectorOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of pattern to unroll vector operations to a smaller shapes. </p>
<p><code>options</code> structure controls which operations are unrolled and the target shape. <code>op</code> is unrolled to the <code>targetShape</code> as follows, for each of its operands:</p><ol type="1">
<li>the unrolled type <code>unrolledVectorType</code> and number of unrolled instances <code>numUnrolledInstances</code> are computed from the <code>targetShape</code>. For now it is assumed the unrolling factors divide the vector sizes.</li>
<li>ExtractStridedSlice are created to break-up the vector operands.</li>
<li>the original op is cloned <code>numUnrolledInstances</code> times, once for each result.</li>
<li>InsertStridedSlice are inserted to re-assemble the slices into the original vectore shape.</li>
</ol>
<p>Example:</p>
<p>opA(operand0, operand1) // numUnrolledInstances = 3 </p><pre class="fragment">    operand0                   operand1
       |                          |
     fork                       fork
&lt;----------gather all fork ops ---------&gt;
      /|\                        /|\
  f00 f01 f02                f10 f11 f12
&lt;---------- clone op 3 times ---------&gt;
  opA0(f00, f10), opA1(f01, f11), opA2(f02, f12)
         \            |            /
</pre><p> &lt;-----------------&mdash; join ----------------------&mdash;&gt;</p>
<p>Other local patterns then kick in iteratively (including DCE) and compose to combine the ExtractStridedSlice/InsertStridedSlice. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03889">3889</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l03897">populateVectorTransferCollapseInnerMostContiguousDimsPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8h_source.html#l00051">mlir::vector::UnrollVectorOptions::setNativeShape()</a>.</p>

</div>
</div>
<a id="a04ec3f2bf8bf50a023677a0981683da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ec3f2bf8bf50a023677a0981683da5">&#9670;&nbsp;</a></span>populateVetorReductionToContractPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVetorReductionToContractPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect patterns to convert reduction op to vector.contract and fold transpose/broadcast ops into the contract. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l03866">3866</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00920">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00896">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00188">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="aea008e69d7dd969b5e885803b759a338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea008e69d7dd969b5e885803b759a338">&#9670;&nbsp;</a></span>splitFullAndPartialTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::vector::splitFullAndPartialTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp *&#160;</td>
          <td class="paramname"><em>ifOp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath. </p>
<p>For vector.transfer_read: If <code>ifOp</code> is not null and the result is <code>success, the</code>ifOp` points to the newly created conditional upon function return. To accomodate for the fact that the original vector.transfer indexing may be arbitrary and the slow path indexes @[0...0] in the temporary buffer, the scf.if op returns a view and values of type index.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fastpath, direct cast memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slowpath, not in-bounds vector.transfer or linalg.copy. memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ... true]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>For vector.transfer_write: There are 2 conditional blocks. First a block to decide which memref and indices to use for an unmasked, inbounds write. Then a conditional block to further copy a partial buffer into the final result in the slow path case.</p>
<p>Example (a 2-D vector.transfer_write): ``` vector.transfer_write arg, %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index } %0 = vector.transfer_write arg, %1#0[%1#1, %1#2] {in_bounds = [true ... true]} scf.if (notInBounds) { // slowpath: not in-bounds vector.transfer or linalg.copy. } ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.permutation_map()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.source()</code> and the rank of the <code>xferOp.vector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02348">2348</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00456">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8h_source.html#l00407">mlir::OpBuilder::create()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02099">createFullPartialLinalgCopy()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02150">createFullPartialVectorTransferRead()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02270">createFullPartialVectorTransferWrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01950">createInBoundsCond()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00055">elementType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00213">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02007">getCastCompatibleMemRefType()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00052">mlir::Builder::getIndexType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02201">getLocationToWriteFullVec()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="Operation_8h_source.html#l00355">mlir::Operation::setAttr()</a>, <a class="el" href="Builders_8h_source.html#l00314">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00347">mlir::OpBuilder::setInsertionPointToStart()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01982">splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="VectorOps_8h_source.html#l00187">mlir::vector::VectorTransformsOptions::vectorTransferSplit</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02458">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, and <a class="el" href="VectorTransforms_8h_source.html#l00051">mlir::vector::UnrollVectorOptions::setNativeShape()</a>.</p>

</div>
</div>
<a id="a2b1dd46b0167a6584fc56b4ac45a1c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1dd46b0167a6584fc56b4ac45a1c1a">&#9670;&nbsp;</a></span>splitFullAndPartialTransferPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::vector::splitFullAndPartialTransferPrecondition </td>
          <td>(</td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath. </p>
<p>If <code>ifOp</code> is not null and the result is <code>success, the</code>ifOp` points to the newly created conditional upon function return. To accomodate for the fact that the original vector.transfer indexing may be arbitrary and the slow path indexes @[0...0] in the temporary buffer, the scf.if op returns a view and values of type index. At this time, only vector.transfer_read case is implemented.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fastpath, direct cast memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slowpath, not in-bounds vector.transfer or linalg.copy. memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ... true]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.permutation_map()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.memref()</code> and the rank of the <code>xferOp.vector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l01982">1982</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02458">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00051">mlir::vector::UnrollVectorOptions::setNativeShape()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02348">splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="ab5d04193b4ea065cbb468158c3a7e4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d04193b4ea065cbb468158c3a7e4a2">&#9670;&nbsp;</a></span>transferOpflowOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::transferOpflowOpt </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements transfer op write to read forwarding and dead transfer write optimizations. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00214">214</a> of file <a class="el" href="VectorTransferOpTransforms_8cpp_source.html">VectorTransferOpTransforms.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 23 2021 15:26:01 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
